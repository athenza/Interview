## 一、面向对象的设计原则

###面向对象的六大设计原则

创建型模式\(Creational Pattern\)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

创建型模式在创建什么\(What\)，由谁创建\(Who\)，何时创建\(When\)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

## 包含设计原则

* **开闭原则（OCP）**



* **接口隔离原则（ISP）**



* **迪米特原则（LOD）**



* **单一职责原则（SRP）**



* **里式替换原则（LSP）**



* **依赖倒置原则（DIP）**


## 一、单一职责原则（Single Responsibility Principle，简称SRP ）

- 定义：应该有且仅有一个原因引起类的变更。

- 描述：
  
  一个类只负责一项职责，如果发生变更时，可以考虑将一个类拆分成两个类，或者在一个类中添加新的方法。
  
  **在真实的开发中，不仅仅是类、函数和接口也要遵循单一职责原则。即：一个函数负责一个功能。如果一个函数里面有不同的功能，则需要将不同的功能的函数分离出去。**


- 优点：

	1. 类的复杂性降低，实现什么职责都有清晰明确的定义。
	2. 类的可读性提高，复杂性减低。


- 效果：
	
	如果接口或者函数的单一职责做得好，一个接口或者函数的修改只对相应的类有影响，对其他接口或者函数无影响，这对系统的扩展性、维护性都有非常大的帮助。

## 二、里氏替换原则（Liskov Substitution Principle，简称LSP）

- 定义：

	如果对一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。
	
- 描述	
	
	**通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。**

	面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。当使用继承时，遵循里氏替换原则。但是使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生影响。子类可以扩展父类的功能，但不能改变父类原有的功能。


	####注意：
	- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
	- 子类中可以增加自己特有的方法。
	- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
	- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。



## 三、依赖倒置原则（Dependence Inversion Principle，简称DIP）

- 定义：	

	模块间的依赖通过抽象发生，高层模块和低层模块之间不应该发生直接的依赖关系，二者都应该是通过接口或抽象类产生的；即依赖抽象，而不依赖具体的实现。
	
	**依赖倒置原则的核心思想是面向接口编程。**
	
- 描述：

	例如：类 A 直接依赖类 B，假如要将类 A 改为依赖类 C，则必须通过修改类 A 的代码来达成。比如在这种场景下，业务逻辑层类 A 相对于数据层类 B 是高层模块，因为业务逻辑层需要调用数据层去连接数据库，如果业务逻辑层类 A 依赖数据层类 B 的话，那么将来需求变更，需要把旧的数据层类 B 修改为新的数据层类 C，就必须通过修改类 A，这样就会给应用程序带来不必要的风险。
	
	
	解决方案：将类 A 修改为依赖接口 I，类 B 和类 C 各自实现接口 I，类 A 通过接口 I 间接与类 B 或者类 C 发生联系，则会大大降低修改类 A 的几率。要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。

	
	
## 四、接口隔离原则（Interface Segregation Principle,简称ISP）

- 定义：	

  客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

- 描述：

	比如，类 A 依赖接口 H 中的方法1、方法2、方法5，类 B 是对类 A 依赖的实现。类 C 依赖接口 H 中的方法3、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法，但由于实现了接口 H，因为接口 H 对于类 A 和类 C 来说不是最小接口，所以也必须要实现这些用不到的方法。

  
  
可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。
解决方法：将臃肿的接口 H 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。


接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。在实际项目开发中，只暴露给调用的类需要的方法，不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，不要试图去建立一个很庞大的接口供所有依赖它的类去调用。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。


## 五、迪米特法则（Law of Demeter，简称LOD）

- 定义：

  一个对象应该对其他对象保持最少的了解。
  
  
- 描述：
  
  当类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外只暴露必要的接口。

	解决方案：尽量降低类与类之间的耦合。


	耦合的方式很多，依赖、关联、组合、聚合等。

	迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是过分的使用迪米特原则，会产生大量传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。


##六、开闭原则（Open Close Principle，简称OCP）

- 定义：
	
  一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
  
  核心思想：尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。	
	
	用抽象构建框架，用实现扩展细节，对扩展开放的关键是抽象，而对象的多态则保证了这种扩展的开放性。开放原则首先意味着我们可以自由地增加功能，而不会影响原有功能。这就要求我们能够通过继承完成功能的扩展。其次，开放原则还意味着实现是可替换的。只有利用抽象，才可以为定义提供不同的实现，然后根据不同的需求实例化不同的实现子类。

- 开放封闭原则的优点：

	- 代码可读性高，可维护性强。
	- 帮助缩小逻辑粒度，以提高可复用性。
	- 可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性。
	- 在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求。
